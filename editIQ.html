<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>maxEdit - 3D Content Editor</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
    <style>
        /* Custom styles for a modern, minimalist aesthetic */
        body {
            font-family: 'Inter', sans-serif;
            background-color: #000000;
            color: #E0E0E0;
            overflow: hidden; /* Prevent scrollbars */
        }
        #container {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
        }
        #canvas-border {
            position: fixed;
            box-sizing: border-box; /* Ensure border is inside */
            border: 1px solid rgba(255, 255, 255, 0.15); /* Subtle border for the canvas */
            border-radius: 8px; /* Slightly rounded corners for the frame */
            pointer-events: none; /* Make sure it doesn't interfere with mouse events */
        }
        .ui-panel {
            background-color: rgba(28, 28, 30, 0.85); /* Semi-transparent dark panel */
            backdrop-filter: blur(10px);
            -webkit-backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 255, 255, 0.1);
            border-radius: 12px;
            box-shadow: 0 8px 32px 0 rgba(0, 0, 0, 0.37);
        }
        .control-group {
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
            padding-bottom: 1rem;
            margin-bottom: 1rem;
        }
        .control-group:last-child {
            border-bottom: none;
            margin-bottom: 0;
            padding-bottom: 0;
        }
        .input-field {
            background-color: rgba(0, 0, 0, 0.3);
            border: 1px solid rgba(255, 255, 255, 0.2);
            border-radius: 6px;
            color: #FFF;
            padding: 4px 8px;
            width: 60px;
            text-align: center;
        }
        .slider {
            -webkit-appearance: none;
            width: 100%;
            height: 4px;
            background: rgba(255, 255, 255, 0.2);
            outline: none;
            border-radius: 2px;
            transition: background 0.2s;
        }
        .slider::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 14px;
            height: 14px;
            background: #A78BFA; /* A nice violet accent */
            cursor: pointer;
            border-radius: 50%;
            border: 2px solid #1C1C1E;
        }
        .btn {
            background-color: rgba(255, 255, 255, 0.1);
            border: 1px solid rgba(255, 255, 255, 0.1);
            transition: all 0.2s ease-in-out;
        }
        .btn:hover {
            background-color: rgba(255, 255, 255, 0.2);
            border-color: #A78BFA;
        }
        .btn.active {
             background-color: #A78BFA;
             color: #000;
        }
        /* Responsive icon sizing */
        .icon-btn svg {
            width: 18px;
            height: 18px;
        }
        @media (min-width: 768px) { /* md breakpoint */
            .icon-btn svg {
                width: 20px;
                height: 20px;
            }
        }
        /* Custom scrollbar for inspector panel */
        #inspector-panel::-webkit-scrollbar {
            width: 6px;
        }
        #inspector-panel::-webkit-scrollbar-track {
            background: transparent;
        }
        #inspector-panel::-webkit-scrollbar-thumb {
            background-color: rgba(255, 255, 255, 0.2);
            border-radius: 3px;
        }
        #inspector-panel::-webkit-scrollbar-thumb:hover {
            background-color: rgba(255, 255, 255, 0.3);
        }
    </style>
</head>
<body class="bg-black">

    <input type="file" id="image-upload" accept="image/*" class="hidden">

    <!-- 3D Viewport -->
    <div id="container"></div>
    <!-- The new border element for the editing area -->
    <div id="canvas-border"></div>

    <!-- UI Panels -->
    <!-- Top Header -->
    <header class="ui-panel absolute top-4 left-1/2 -translate-x-1/2 flex items-center gap-1 md:gap-2 px-2 md:px-4 py-2 z-10 whitespace-nowrap">
        <h1 class="text-base md:text-lg font-bold tracking-wider">max<span class="text-purple-400">Edit</span></h1>
        <div class="h-6 w-px bg-white/10"></div>
        <div class="flex items-center gap-1 md:gap-2">
            <button id="export-gltf" class="btn text-xs px-2 md:px-3 py-1 rounded-md">Export GLTF</button>
            <button id="export-obj" class="btn text-xs px-2 md:px-3 py-1 rounded-md">Export OBJ</button>
            <button id="export-png" class="btn text-xs px-2 md:px-3 py-1 rounded-md">Export Image</button>
        </div>
    </header>
    
    <!-- Main Toolbar -->
    <div id="main-toolbar" class="ui-panel absolute top-20 left-1/2 -translate-x-1/2 flex items-center gap-1 md:gap-2 px-2 md:px-4 py-2 z-10">
        <button id="add-cube" class="btn icon-btn p-1 md:p-2 rounded-lg" title="Add Cube">
            <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" d="M21 7.5l-9-5.25L3 7.5m18 0l-9 5.25m9-5.25v9l-9 5.25M3 7.5l9 5.25M3 7.5v9l9 5.25m0-9v9" /></svg>
        </button>
        <button id="add-sphere" class="btn icon-btn p-1 md:p-2 rounded-lg" title="Add Sphere">
            <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" d="M12.75 19.5v-.75a7.5 7.5 0 00-7.5-7.5H4.5m0-6.75h.75c7.28 0 13.25 5.97 13.25 13.25v.75" /></svg>
        </button>
        <button id="add-text" class="btn icon-btn p-1 md:p-2 rounded-lg" title="Add Text">
           <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="currentColor"><path d="M9.625 5.5h4.75a.875.875 0 0 1 0 1.75h-1.5v9.375a.875.875 0 0 1-1.75 0V7.25h-1.5a.875.875 0 0 1 0-1.75Z"/></svg>
        </button>
        <button id="add-image" class="btn icon-btn p-1 md:p-2 rounded-lg" title="Add Image Plane">
            <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor">
              <path stroke-linecap="round" stroke-linejoin="round" d="M6.827 6.175A2.31 2.31 0 015.186 7.23c-.38.054-.757.112-1.134.175C2.999 7.58 2.25 8.507 2.25 9.574V18a2.25 2.25 0 002.25 2.25h15A2.25 2.25 0 0021.75 18V9.574c0-1.067-.75-1.994-1.802-2.169a47.865 47.865 0 00-1.134-.175 2.31 2.31 0 01-1.64-1.055l-.822-1.316a2.192 2.192 0 00-1.736-1.039 48.776 48.776 0 00-5.232 0 2.192 2.192 0 00-1.736 1.039l-.821 1.316z" />
              <path stroke-linecap="round" stroke-linejoin="round" d="M16.5 12.75a4.5 4.5 0 11-9 0 4.5 4.5 0 019 0zM18.75 10.5h.008v.008h-.008V10.5z" />
            </svg>
        </button>

        <div class="h-6 w-px bg-white/10 mx-2"></div>

        <button id="tool-move" class="btn icon-btn p-1 md:p-2 rounded-lg active" title="Move (W)">
            <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" d="M8.25 6.75h7.5M8.25 17.25h7.5m-7.5-3.5h7.5m-1.5-6.75l-3.75-3.75-3.75 3.75m6.25 10.5l-3.75 3.75-3.75-3.75M6 12l-3.75 3.75L6 19.5m12-7.5l3.75 3.75L18 19.5" /></svg>
        </button>
        <button id="tool-rotate" class="btn icon-btn p-1 md:p-2 rounded-lg" title="Rotate (E)">
            <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" d="M15.75 5.25a3 3 0 013 3m3 0a6 6 0 01-7.029 5.912c-.563-.097-1.159.026-1.563.43L10.5 17.25H8.25v2.25H6v2.25H2.25v-2.818c0-.597.237-1.17.659-1.591l6.499-6.499c.404-.404.527-1 .43-1.563A6 6 0 1121.75 8.25z" /></svg>
        </button>
        <button id="tool-scale" class="btn icon-btn p-1 md:p-2 rounded-lg" title="Scale (R)">
            <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" d="M3.75 3.75v4.5m0-4.5h4.5m-4.5 0L9 9M3.75 20.25v-4.5m0 4.5h4.5m-4.5 0L9 15M20.25 3.75h-4.5m4.5 0v4.5m0-4.5L15 9m5.25 11.25h-4.5m4.5 0v-4.5m0 4.5L15 15" /></svg>
        </button>
        <div class="h-6 w-px bg-white/10 mx-2"></div>
         <button id="tool-delete" class="btn icon-btn p-1 md:p-2 rounded-lg text-red-400 hover:text-red-300" title="Delete (Del)">
            <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" d="M14.74 9l-.346 9m-4.788 0L9.26 9m9.968-3.21c.342.052.682.107 1.022.166m-1.022-.165L18.16 19.673a2.25 2.25 0 01-2.244 2.077H8.084a2.25 2.25 0 01-2.244-2.077L4.772 5.79m14.456 0a48.108 48.108 0 00-3.478-.397m-12 .562c.34-.059.68-.114 1.022-.165m0 0a48.11 48.11 0 013.478-.397m7.5 0v-.916c0-1.18-.91-2.164-2.09-2.201a51.964 51.964 0 00-3.32 0c-1.18.037-2.09 1.022-2.09 2.201v.916m7.5 0a48.667 48.667 0 00-7.5 0" /></svg>
        </button>
    </div>

    <!-- Right Sidebar: Properties Inspector -->
    <div id="inspector-panel" class="ui-panel absolute right-4 w-64 p-5 hidden overflow-y-auto">
        <div class="control-group">
            <h3 class="font-semibold mb-3 text-sm">Transform</h3>
            <div class="space-y-3 text-xs">
                <!-- Position -->
                <div class="space-y-2">
                    <label class="font-medium">Position</label>
                    <div class="grid grid-cols-[20px,1fr,60px] gap-2 items-center">
                        <label for="pos-x-slider" class="text-gray-400">X</label>
                        <input type="range" min="-10" max="10" step="0.1" class="slider" id="pos-x-slider">
                        <input type="number" step="0.1" class="input-field w-full" id="pos-x">
                    </div>
                    <div class="grid grid-cols-[20px,1fr,60px] gap-2 items-center">
                        <label for="pos-y-slider" class="text-gray-400">Y</label>
                        <input type="range" min="-10" max="10" step="0.1" class="slider" id="pos-y-slider">
                        <input type="number" step="0.1" class="input-field w-full" id="pos-y">
                    </div>
                    <div class="grid grid-cols-[20px,1fr,60px] gap-2 items-center">
                        <label for="pos-z-slider" class="text-gray-400">Z</label>
                        <input type="range" min="-10" max="10" step="0.1" class="slider" id="pos-z-slider">
                        <input type="number" step="0.1" class="input-field w-full" id="pos-z">
                    </div>
                </div>

                <!-- Rotation -->
                <div class="space-y-2 pt-2">
                    <label class="font-medium">Rotation</label>
                    <div class="grid grid-cols-[20px,1fr,60px] gap-2 items-center">
                        <label for="rot-x-slider" class="text-gray-400">X</label>
                        <input type="range" min="0" max="360" step="1" class="slider" id="rot-x-slider">
                        <input type="number" step="1" class="input-field w-full" id="rot-x">
                    </div>
                     <div class="grid grid-cols-[20px,1fr,60px] gap-2 items-center">
                        <label for="rot-y-slider" class="text-gray-400">Y</label>
                        <input type="range" min="0" max="360" step="1" class="slider" id="rot-y-slider">
                        <input type="number" step="1" class="input-field w-full" id="rot-y">
                    </div>
                     <div class="grid grid-cols-[20px,1fr,60px] gap-2 items-center">
                        <label for="rot-z-slider" class="text-gray-400">Z</label>
                        <input type="range" min="0" max="360" step="1" class="slider" id="rot-z-slider">
                        <input type="number" step="1" class="input-field w-full" id="rot-z">
                    </div>
                </div>

                <!-- Scale -->
                <div class="space-y-2 pt-2">
                    <label class="font-medium">Scale</label>
                    <div class="grid grid-cols-[20px,1fr,60px] gap-2 items-center">
                        <label for="scl-x-slider" class="text-gray-400">X</label>
                        <input type="range" min="0.1" max="5" step="0.05" class="slider" id="scl-x-slider">
                        <input type="number" step="0.1" class="input-field w-full" id="scl-x">
                    </div>
                    <div class="grid grid-cols-[20px,1fr,60px] gap-2 items-center">
                        <label for="scl-y-slider" class="text-gray-400">Y</label>
                        <input type="range" min="0.1" max="5" step="0.05" class="slider" id="scl-y-slider">
                        <input type="number" step="0.1" class="input-field w-full" id="scl-y">
                    </div>
                    <div class="grid grid-cols-[20px,1fr,60px] gap-2 items-center">
                        <label for="scl-z-slider" class="text-gray-400">Z</label>
                        <input type="range" min="0.1" max="5" step="0.05" class="slider" id="scl-z-slider">
                        <input type="number" step="0.1" class="input-field w-full" id="scl-z">
                    </div>
                </div>
            </div>
        </div>
        <div class="control-group">
            <h3 class="font-semibold mb-3 text-sm">Style</h3>
            <div class="space-y-3 text-xs">
                 <!-- Opacity -->
                <div class="grid grid-cols-[50px,1fr,40px] gap-2 items-center">
                    <label for="opacity-slider">Opacity</label>
                    <input type="range" min="0" max="1" step="0.01" class="slider" id="opacity-slider">
                    <span id="opacity-value">1.0</span>
                </div>
                <!-- Color Picker -->
                <div class="grid grid-cols-[50px,1fr] gap-2 items-center">
                    <label for="color-picker">Color</label>
                    <input type="color" id="color-picker" class="w-full h-7 p-0 border-none rounded cursor-pointer" style="background-color: transparent;">
                </div>
                 <!-- Saturation -->
                <div class="grid grid-cols-[50px,1fr,40px] gap-2 items-center">
                    <label for="saturation-slider">Saturation</label>
                    <input type="range" min="0" max="1" step="0.01" class="slider" id="saturation-slider">
                    <span id="saturation-value">1.0</span>
                </div>
            </div>
        </div>
        <div id="text-style-group" class="control-group hidden">
             <h3 class="font-semibold mb-3 text-sm">Text Style</h3>
             <div class="space-y-3 text-xs">
                 <!-- Font Size -->
                <div class="grid grid-cols-[70px,1fr,40px] gap-2 items-center">
                    <label for="font-size-slider">Font Size</label>
                    <input type="range" min="8" max="200" step="1" class="slider" id="font-size-slider">
                    <span id="font-size-value">40</span>
                </div>
                <!-- Extrusion -->
                <div class="grid grid-cols-[70px,1fr,40px] gap-2 items-center">
                    <label for="extrusion-slider">Extrusion</label>
                    <input type="range" min="0" max="100" step="1" class="slider" id="extrusion-slider">
                    <span id="extrusion-value">5</span>
                </div>
             </div>
        </div>
    </div>
    <div id="inspector-placeholder" class="ui-panel absolute right-4 w-64 p-5 text-center text-gray-400 text-sm flex flex-col justify-center">
        <p>Select an object to edit its properties.</p>
    </div>

    <!-- Bottom Bar: History & Camera -->
     <div class="ui-panel absolute bottom-4 left-1/2 -translate-x-1/2 flex items-center gap-1 md:gap-2 px-2 md:px-4 py-2 whitespace-nowrap">
        <!-- History -->
        <button id="undo-btn" class="btn icon-btn p-1 md:p-2 rounded-lg" title="Undo">
            <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" d="M9 15L3 9m0 0l6-6M3 9h12a6 6 0 010 12h-3" /></svg>
        </button>
        <button id="redo-btn" class="btn icon-btn p-1 md:p-2 rounded-lg" title="Redo">
            <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" d="M15 15l6-6m0 0l-6-6m6 6H9a6 6 0 000 12h3" /></svg>
        </button>
        <div class="h-6 w-px bg-white/10 mx-2"></div>
        <!-- Camera Presets -->
        <button id="cam-front" class="btn text-xs px-2 md:px-3 py-1 rounded-md">Front</button>
        <button id="cam-top" class="btn text-xs px-2 md:px-3 py-1 rounded-md">Top</button>
        <button id="cam-side" class="btn text-xs px-2 md:px-3 py-1 rounded-md">Side</button>
        <button id="cam-iso" class="btn text-xs px-2 md:px-3 py-1 rounded-md">Isometric</button>
        <button id="cam-reset" class="btn text-xs px-2 md:px-3 py-1 rounded-md">Reset</button>
     </div>


    <script type="importmap">
        {
            "imports": {
                "three": "https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.module.js",
                "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/"
            }
        }
    </script>
    <script type="module">
        import * as THREE from 'three';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
        import { TransformControls } from 'three/addons/controls/TransformControls.js';
        import { FontLoader } from 'three/addons/loaders/FontLoader.js';
        import { TextGeometry } from 'three/addons/geometries/TextGeometry.js';
        import { GLTFExporter } from 'three/addons/exporters/GLTFExporter.js';
        import { OBJExporter } from 'three/addons/exporters/OBJExporter.js';

        // --- Core Scene Setup ---
        let scene, camera, renderer, orbitControls, transformControls;
        let raycaster, mouse;
        let selectedObject = null;
        const sceneObjects = [];
        const initialCameraPosition = new THREE.Vector3(5, 5, 10);

        // --- UI Elements ---
        const container = document.getElementById('container');
        const canvasBorder = document.getElementById('canvas-border');
        const inspectorPanel = document.getElementById('inspector-panel');
        const inspectorPlaceholder = document.getElementById('inspector-placeholder');
        const textStyleGroup = document.getElementById('text-style-group');
        const imageUploadInput = document.getElementById('image-upload');
        
        // Transform Sliders
        const posXSlider = document.getElementById('pos-x-slider');
        const posYSlider = document.getElementById('pos-y-slider');
        const posZSlider = document.getElementById('pos-z-slider');
        const rotXSlider = document.getElementById('rot-x-slider');
        const rotYSlider = document.getElementById('rot-y-slider');
        const rotZSlider = document.getElementById('rot-z-slider');
        const sclXSlider = document.getElementById('scl-x-slider');
        const sclYSlider = document.getElementById('scl-y-slider');
        const sclZSlider = document.getElementById('scl-z-slider');

        // Transform Inputs
        const posX = document.getElementById('pos-x');
        const posY = document.getElementById('pos-y');
        const posZ = document.getElementById('pos-z');
        const rotX = document.getElementById('rot-x');
        const rotY = document.getElementById('rot-y');
        const rotZ = document.getElementById('rot-z');
        const sclX = document.getElementById('scl-x');
        const sclY = document.getElementById('scl-y');
        const sclZ = document.getElementById('scl-z');

        // Style Inputs
        const opacitySlider = document.getElementById('opacity-slider');
        const opacityValue = document.getElementById('opacity-value');
        const colorPicker = document.getElementById('color-picker');
        const saturationSlider = document.getElementById('saturation-slider');
        const saturationValue = document.getElementById('saturation-value');
        const fontSizeSlider = document.getElementById('font-size-slider');
        const fontSizeValue = document.getElementById('font-size-value');
        const extrusionSlider = document.getElementById('extrusion-slider');
        const extrusionValue = document.getElementById('extrusion-value');
        
        // --- History (Undo/Redo) ---
        const historyStack = [];
        const redoStack = [];
        const MAX_HISTORY = 50;
        let isDragging = false; // Flag to prevent flooding history during transform

        function init() {
            // Scene
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x000000);

            // Camera
            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.copy(initialCameraPosition);
            camera.lookAt(0, 0, 0);

            // Renderer
            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(window.devicePixelRatio);
            container.appendChild(renderer.domElement);

            // Lighting
            const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
            scene.add(ambientLight);
            const directionalLight = new THREE.DirectionalLight(0xffffff, 1.5);
            directionalLight.position.set(5, 10, 7.5);
            scene.add(directionalLight);

            // Grid Helper
            const gridHelper = new THREE.GridHelper(20, 20, 0x444444, 0x222222);
            scene.add(gridHelper);

            // Controls
            orbitControls = new OrbitControls(camera, renderer.domElement);
            orbitControls.enableDamping = true;

            transformControls = new TransformControls(camera, renderer.domElement);
            transformControls.addEventListener('dragging-changed', event => {
                orbitControls.enabled = !event.value;
                isDragging = event.value;
                if (!isDragging) { // On drag end, push state
                    pushHistoryState();
                }
            });
            transformControls.addEventListener('objectChange', () => {
                 updateInspector();
            });
            scene.add(transformControls);
            
            // Raycasting for selection
            raycaster = new THREE.Raycaster();
            mouse = new THREE.Vector2();

            // Event Listeners
            window.addEventListener('resize', onWindowResize);
            renderer.domElement.addEventListener('click', onClick);
            setupUIListeners();
            
            // Initial Object
            addObject('cube');

            // Set initial canvas bounds
            updateCanvasBounds();

            // Start Animation Loop
            animate();
        }
        
        function animate() {
            requestAnimationFrame(animate);
            orbitControls.update();
            renderer.render(scene, camera);
        }

        function onWindowResize() {
            updateCanvasBounds();
        }

        function updateCanvasBounds() {
            // Get all UI elements that define the boundaries
            const header = document.querySelector('header.ui-panel');
            const mainToolbar = document.getElementById('main-toolbar');
            const rightPanel = inspectorPanel.classList.contains('hidden') ? inspectorPlaceholder : inspectorPanel;
            const bottomBar = document.querySelector('.ui-panel.bottom-4');

            const padding = 20; // Space between UI panels and the canvas border

            // Calculate vertical bounds based on the lowest top-panel
            const top = mainToolbar.getBoundingClientRect().bottom + padding;

            // Calculate horizontal bounds
            const left = padding;
            const right = rightPanel.getBoundingClientRect().left - padding;
            const bottom = bottomBar.getBoundingClientRect().top - padding;

            const newWidth = right - left;
            const newHeight = bottom - top;

            // Update the Right Panels to match canvas vertical bounds
            inspectorPanel.style.top = `${top}px`;
            inspectorPanel.style.height = `${newHeight}px`;
            inspectorPlaceholder.style.top = `${top}px`;
            inspectorPlaceholder.style.height = `${newHeight}px`;

            // Update the border element
            canvasBorder.style.top = `${top}px`;
            canvasBorder.style.left = `${left}px`;
            canvasBorder.style.width = `${newWidth}px`;
            canvasBorder.style.height = `${newHeight}px`;

            // Update the three.js container (it's inside the border)
            container.style.top = `${top}px`;
            container.style.left = `${left}px`;
            container.style.width = `${newWidth}px`;
            container.style.height = `${newHeight}px`;
            
            // Update three.js renderer and camera
            if(camera && renderer) {
                camera.aspect = newWidth / newHeight;
                camera.updateProjectionMatrix();
                renderer.setSize(newWidth, newHeight);
            }
        }


        // --- Object Selection ---
        function onClick(event) {
            // Don't select if dragging gizmo
            if (isDragging) return;
            
            const rect = container.getBoundingClientRect();

            // Calculate mouse position relative to the container element
            const x = event.clientX - rect.left;
            const y = event.clientY - rect.top;

            // Normalize coordinates for the raycaster
            mouse.x = (x / rect.width) * 2 - 1;
            mouse.y = -(y / rect.height) * 2 + 1;

            raycaster.setFromCamera(mouse, camera);
            const intersects = raycaster.intersectObjects(sceneObjects, true);

            if (intersects.length > 0) {
                const object = intersects[0].object;
                 if (object !== selectedObject) {
                    selectObject(object);
                }
            } else {
                deselectObject();
            }
        }
        
        function selectObject(object) {
            selectedObject = object;
            transformControls.attach(object);
            updateInspector();
            inspectorPanel.classList.remove('hidden');
            inspectorPlaceholder.classList.add('hidden');
            updateCanvasBounds(); // Recalculate bounds when inspector appears
        }

        function deselectObject() {
            selectedObject = null;
            transformControls.detach();
            inspectorPanel.classList.add('hidden');
            inspectorPlaceholder.classList.remove('hidden');
            updateCanvasBounds(); // Recalculate bounds when inspector hides
            updateInspector();
        }

        function deleteSelectedObject() {
            if (!selectedObject) return;

            // Remove from scene and data array
            const index = sceneObjects.indexOf(selectedObject);
            if (index > -1) {
                sceneObjects.splice(index, 1);
            }
            scene.remove(selectedObject);

            // Clean up geometry and material
            if(selectedObject.geometry) selectedObject.geometry.dispose();
            if(selectedObject.material) selectedObject.material.dispose();
            
            deselectObject();
        }

        // --- UI & Inspector Logic ---
        function updateInspector() {
            if (selectedObject) {
                // Position
                posX.value = selectedObject.position.x.toFixed(2);
                posXSlider.value = selectedObject.position.x;
                posY.value = selectedObject.position.y.toFixed(2);
                posYSlider.value = selectedObject.position.y;
                posZ.value = selectedObject.position.z.toFixed(2);
                posZSlider.value = selectedObject.position.z;
                // Rotation
                const rotXDeg = THREE.MathUtils.radToDeg(selectedObject.rotation.x);
                const rotYDeg = THREE.MathUtils.radToDeg(selectedObject.rotation.y);
                const rotZDeg = THREE.MathUtils.radToDeg(selectedObject.rotation.z);
                rotX.value = rotXDeg.toFixed(0);
                rotXSlider.value = rotXDeg;
                rotY.value = rotYDeg.toFixed(0);
                rotYSlider.value = rotYDeg;
                rotZ.value = rotZDeg.toFixed(0);
                rotZSlider.value = rotZDeg;
                // Scale
                sclX.value = selectedObject.scale.x.toFixed(2);
                sclXSlider.value = selectedObject.scale.x;
                sclY.value = selectedObject.scale.y.toFixed(2);
                sclYSlider.value = selectedObject.scale.y;
                sclZ.value = selectedObject.scale.z.toFixed(2);
                sclZSlider.value = selectedObject.scale.z;
                
                // Style
                opacitySlider.value = selectedObject.material.opacity;
                opacityValue.textContent = selectedObject.material.opacity.toFixed(2);
                
                const color = new THREE.Color(selectedObject.material.color.getHex());
                colorPicker.value = '#' + color.getHexString();

                const hsl = {};
                color.getHSL(hsl);
                saturationSlider.value = hsl.s;
                saturationValue.textContent = hsl.s.toFixed(2);

                // Text-specific controls
                if (selectedObject.userData.isText) {
                    textStyleGroup.classList.remove('hidden');
                    fontSizeSlider.value = selectedObject.userData.fontSize;
                    fontSizeValue.textContent = selectedObject.userData.fontSize;
                    extrusionSlider.value = selectedObject.userData.extrusion;
                    extrusionValue.textContent = selectedObject.userData.extrusion;
                } else {
                    textStyleGroup.classList.add('hidden');
                }
            }
        }
        
        function updateObjectFromInspector() {
            if (!selectedObject) return;

            // Position
            selectedObject.position.set(parseFloat(posX.value), parseFloat(posY.value), parseFloat(posZ.value));
            // Rotation
            selectedObject.rotation.set(
                parseFloat(rotX.value) * Math.PI / 180,
                parseFloat(rotY.value) * Math.PI / 180,
                parseFloat(rotZ.value) * Math.PI / 180
            );
            // Scale
            selectedObject.scale.set(parseFloat(sclX.value), parseFloat(sclY.value), parseFloat(sclZ.value));
        }

        function setupUIListeners() {
            // Transform Inputs
            const transformInputs = [
                { slider: posXSlider, input: posX, prop: 'position', axis: 'x', fixed: 2 },
                { slider: posYSlider, input: posY, prop: 'position', axis: 'y', fixed: 2 },
                { slider: posZSlider, input: posZ, prop: 'position', axis: 'z', fixed: 2 },
                { slider: rotXSlider, input: rotX, prop: 'rotation', axis: 'x', fixed: 0, isRotation: true },
                { slider: rotYSlider, input: rotY, prop: 'rotation', axis: 'y', fixed: 0, isRotation: true },
                { slider: rotZSlider, input: rotZ, prop: 'rotation', axis: 'z', fixed: 0, isRotation: true },
                { slider: sclXSlider, input: sclX, prop: 'scale', axis: 'x', fixed: 2 },
                { slider: sclYSlider, input: sclY, prop: 'scale', axis: 'y', fixed: 2 },
                { slider: sclZSlider, input: sclZ, prop: 'scale', axis: 'z', fixed: 2 },
            ];

            transformInputs.forEach(({ slider, input, prop, axis, fixed, isRotation }) => {
                slider.addEventListener('input', () => {
                    if (!selectedObject) return;
                    const value = parseFloat(slider.value);
                    input.value = value.toFixed(fixed);
                    const finalValue = isRotation ? THREE.MathUtils.degToRad(value) : value;
                    selectedObject[prop][axis] = finalValue;
                });
                slider.addEventListener('change', pushHistoryState);

                input.addEventListener('change', () => {
                    if (!selectedObject) return;
                    const value = parseFloat(input.value);
                    slider.value = value;
                    const finalValue = isRotation ? THREE.MathUtils.degToRad(value) : value;
                    selectedObject[prop][axis] = finalValue;
                    pushHistoryState();
                });
            });
            
            // Style Inputs
            opacitySlider.addEventListener('input', () => {
                if (!selectedObject) return;
                const value = parseFloat(opacitySlider.value);
                selectedObject.material.opacity = value;
                selectedObject.material.transparent = value < 1.0;
                opacityValue.textContent = value.toFixed(2);
            });
            opacitySlider.addEventListener('change', pushHistoryState); // On release
            
            colorPicker.addEventListener('input', () => {
                if (!selectedObject) return;
                selectedObject.material.color.set(colorPicker.value);
                // Also update saturation slider as the color has changed
                const color = new THREE.Color(colorPicker.value);
                const hsl = {};
                color.getHSL(hsl);
                saturationSlider.value = hsl.s;
                saturationValue.textContent = hsl.s.toFixed(2);
            });
            colorPicker.addEventListener('change', pushHistoryState);

            saturationSlider.addEventListener('input', () => {
                if (!selectedObject) return;
                const saturation = parseFloat(saturationSlider.value);
                const color = new THREE.Color();
                const currentHSL = {};
                selectedObject.material.color.getHSL(currentHSL);
                color.setHSL(currentHSL.h, saturation, currentHSL.l);
                selectedObject.material.color.set(color);
                saturationValue.textContent = saturation.toFixed(2);
            });
            saturationSlider.addEventListener('change', pushHistoryState);
            
            // Text Inputs
            fontSizeSlider.addEventListener('input', () => {
                 if (!selectedObject || !selectedObject.userData.isText) return;
                 fontSizeValue.textContent = fontSizeSlider.value;
                 updateTextGeometry();
            });
            fontSizeSlider.addEventListener('change', pushHistoryState);

            extrusionSlider.addEventListener('input', () => {
                 if (!selectedObject || !selectedObject.userData.isText) return;
                 extrusionValue.textContent = extrusionSlider.value;
                 updateTextGeometry();
            });
            extrusionSlider.addEventListener('change', pushHistoryState);

            // Add Object Buttons
            document.getElementById('add-cube').addEventListener('click', () => addObject('cube'));
            document.getElementById('add-sphere').addEventListener('click', () => addObject('sphere'));
            document.getElementById('add-text').addEventListener('click', () => addObject('text'));
            document.getElementById('add-image').addEventListener('click', () => {
                imageUploadInput.click();
            });

            imageUploadInput.addEventListener('change', (event) => {
                const file = event.target.files[0];
                if (file) {
                    const reader = new FileReader();
                    reader.onload = (e) => {
                        addObject('image', { imageUrl: e.target.result });
                    };
                    reader.readAsDataURL(file);
                    imageUploadInput.value = ''; // Allow re-uploading the same file
                }
            });
            
            // New Transform Toolbar Buttons
            const toolMoveBtn = document.getElementById('tool-move');
            const toolRotateBtn = document.getElementById('tool-rotate');
            const toolScaleBtn = document.getElementById('tool-scale');
            const toolDeleteBtn = document.getElementById('tool-delete');
            const toolBtns = [toolMoveBtn, toolRotateBtn, toolScaleBtn];

            const setActiveTool = (activeBtn) => {
                toolBtns.forEach(btn => btn.classList.remove('active'));
                activeBtn.classList.add('active');
            };

            toolMoveBtn.addEventListener('click', () => {
                transformControls.setMode('translate');
                setActiveTool(toolMoveBtn);
            });
            toolRotateBtn.addEventListener('click', () => {
                transformControls.setMode('rotate');
                setActiveTool(toolRotateBtn);
            });
            toolScaleBtn.addEventListener('click', () => {
                transformControls.setMode('scale');
                setActiveTool(toolScaleBtn);
            });
            toolDeleteBtn.addEventListener('click', deleteSelectedObject);


            // Camera Buttons
            document.getElementById('cam-front').addEventListener('click', () => setCameraView(0, 0, 10));
            document.getElementById('cam-top').addEventListener('click', () => setCameraView(0, 10, 0.01));
            document.getElementById('cam-side').addEventListener('click', () => setCameraView(10, 0, 0));
            document.getElementById('cam-iso').addEventListener('click', () => setCameraView(10, 10, 10));
            document.getElementById('cam-reset').addEventListener('click', () => setCameraView(initialCameraPosition.x, initialCameraPosition.y, initialCameraPosition.z));

            // History Buttons
            document.getElementById('undo-btn').addEventListener('click', undo);
            document.getElementById('redo-btn').addEventListener('click', redo);
            
            // Export Buttons
            document.getElementById('export-gltf').addEventListener('click', exportGLTF);
            document.getElementById('export-obj').addEventListener('click', exportOBJ);
            document.getElementById('export-png').addEventListener('click', exportPNG);
        }

        // --- Object Creation ---
        const fontLoader = new FontLoader();
        let defaultFont = null;
        fontLoader.load('https://cdn.jsdelivr.net/npm/three@0.160.0/examples/fonts/helvetiker_regular.typeface.json', (font) => {
            defaultFont = font;
        });

        function addObject(type, options = {}) {
            let geometry, material, mesh;
            material = new THREE.MeshStandardMaterial({ color: 0xcccccc, roughness: 0.5 });
            
            switch(type) {
                case 'cube':
                    geometry = new THREE.BoxGeometry(1, 1, 1);
                    mesh = new THREE.Mesh(geometry, material);
                    break;
                case 'sphere':
                    geometry = new THREE.SphereGeometry(0.75, 32, 16);
                    mesh = new THREE.Mesh(geometry, material);
                    break;
                case 'text':
                    if (!defaultFont) { alert('Font not loaded yet.'); return; }
                     const textGeo = new TextGeometry('Hello 3D', {
                        font: defaultFont,
                        size: 1,
                        height: 0.2,
                        curveSegments: 12,
                        bevelEnabled: true,
                        bevelThickness: 0.03,
                        bevelSize: 0.02,
                        bevelOffset: 0,
                        bevelSegments: 5
                    });
                    textGeo.center();
                    mesh = new THREE.Mesh(textGeo, material);
                    mesh.userData = { isText: true, text: 'Hello 3D', fontSize: 100, extrusion: 20 }; // Note: size here is different from UI
                    mesh.scale.set(0.01, 0.01, 0.01); // Scale down to a manageable size
                    break;
                case 'image': {
                    geometry = new THREE.PlaneGeometry(2, 2); // Default size
                    const imageUrl = options.imageUrl;
                    if (!imageUrl) {
                        console.error("No image URL provided for image object.");
                        return;
                    }

                    const imageMaterial = new THREE.MeshStandardMaterial({
                        side: THREE.DoubleSide,
                        transparent: true,
                    });
                    mesh = new THREE.Mesh(geometry, imageMaterial);

                    const textureLoader = new THREE.TextureLoader();
                    textureLoader.load(imageUrl, (texture) => {
                        mesh.material.map = texture;
                        mesh.material.needsUpdate = true;
                        
                        // Adjust aspect ratio by scaling
                        const aspectRatio = texture.image.width / texture.image.height;
                        mesh.scale.x = mesh.scale.y * aspectRatio;
                        
                        // If this is the currently selected object, update the inspector
                        if (selectedObject === mesh) {
                            updateInspector();
                        }
                    });
                    break;
                }
            }

            if(mesh) {
                scene.add(mesh);
                sceneObjects.push(mesh);
                selectObject(mesh);
                pushHistoryState(); // Add creation to history
            }
        }
        
        function updateTextGeometry() {
             if (!selectedObject || !selectedObject.userData.isText) return;
             const userData = selectedObject.userData;
             userData.fontSize = parseFloat(fontSizeSlider.value);
             userData.extrusion = parseFloat(extrusionSlider.value);
             
             const newGeometry = new TextGeometry(userData.text, {
                font: defaultFont,
                size: userData.fontSize,
                height: userData.extrusion,
                curveSegments: 12,
                bevelEnabled: true,
                bevelThickness: 0.03 * userData.fontSize,
                bevelSize: 0.02 * userData.fontSize,
                bevelOffset: 0,
                bevelSegments: 5
             });
             newGeometry.center();
             selectedObject.geometry.dispose();
             selectedObject.geometry = newGeometry;
        }

        // --- Camera Controls ---
        function setCameraView(x, y, z) {
            camera.position.set(x, y, z);
            camera.lookAt(0, 0, 0);
        }

        // --- History Management ---
        function captureState(object) {
            if (!object) return null;
            const state = {
                uuid: object.uuid,
                position: object.position.clone(),
                rotation: object.rotation.clone(),
                scale: object.scale.clone(),
                material: object.material.clone(),
            };
            if (object.userData.isText) {
                 state.userData = JSON.parse(JSON.stringify(object.userData));
            }
            return state;
        }

        function applyState(object, state) {
            if (!object || !state) return;
            object.position.copy(state.position);
            object.rotation.copy(state.rotation);
            object.scale.copy(state.scale);
            object.material.copy(state.material);
             if (state.userData && state.userData.isText) {
                object.userData = JSON.parse(JSON.stringify(state.userData));
                // We need to rebuild geometry from userData after applying state
                updateTextGeometry(); 
            }
            updateInspector();
        }

        function pushHistoryState() {
            if (!selectedObject) return;
            const state = captureState(selectedObject);
            historyStack.push(state);
            if (historyStack.length > MAX_HISTORY) {
                historyStack.shift();
            }
            redoStack.length = 0; // Clear redo stack on new action
        }
        
        function undo() {
            if (historyStack.length <= 1) return; // Keep at least one initial state
            const currentState = historyStack.pop();
            redoStack.push(currentState);

            const prevState = historyStack[historyStack.length - 1];
            const object = scene.getObjectByProperty('uuid', prevState.uuid);
            applyState(object, prevState);
        }

        function redo() {
            if (redoStack.length === 0) return;
            const nextState = redoStack.pop();
            historyStack.push(nextState);
            const object = scene.getObjectByProperty('uuid', nextState.uuid);
            applyState(object, nextState);
        }

        // --- Export Functions ---
        function exportGLTF() {
            const exporter = new GLTFExporter();
            exporter.parse(
                scene,
                function (gltf) {
                    const output = JSON.stringify(gltf, null, 2);
                    saveString(output, 'scene.gltf');
                },
                function (error) {
                    console.error('An error happened during parsing', error);
                },
                { onlyVisible: true, trs: false, binary: false }
            );
        }
        
        function exportOBJ() {
            const exporter = new OBJExporter();
            const result = exporter.parse(scene);
            saveString(result, 'scene.obj');
        }

        function exportPNG() {
            const scaleFactor = 4; // Export at 4x resolution for higher quality
            const originalSize = new THREE.Vector2();
            renderer.getSize(originalSize);

            const newWidth = originalSize.width * scaleFactor;
            const newHeight = originalSize.height * scaleFactor;

            // Temporarily resize renderer and update camera
            renderer.setSize(newWidth, newHeight, false);
            camera.aspect = newWidth / newHeight;
            camera.updateProjectionMatrix();
            
            // Render the scene at high resolution
            renderer.render(scene, camera);
            const dataURL = renderer.domElement.toDataURL('image/png');
            
            // Restore original size
            renderer.setSize(originalSize.width, originalSize.height, false);
            camera.aspect = originalSize.width / originalSize.height;
            camera.updateProjectionMatrix();

            saveData(dataURL, 'maxEdit-export.png');
        }
        
        const link = document.createElement('a');
        link.style.display = 'none';
        document.body.appendChild(link);

        function save(blob, filename) {
            link.href = URL.createObjectURL(blob);
            link.download = filename;
            link.click();
        }
        
        function saveString(text, filename) {
            save(new Blob([text], {type: 'text/plain'}), filename);
        }

        function saveData(data, filename) {
             link.href = data;
             link.download = filename;
             link.click();
        }


        // --- Initialize ---
        init();

    </script>
</body>
</html>

